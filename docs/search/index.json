[{"content":"I have been working really hard on melon the past month, and it\u0026rsquo;s getting close to V1 being feature complete! I\u0026rsquo;ve worked on lots of things, but for this post I wanted to talk about the scanner. The last time I talked about Melon the scanner was working but really slow. Especially on my HDD. So I spent awhile looking for optimizations and eventually ended up rewritting the scanner, which I\u0026rsquo;ve called Scanner V2.\nThe old scanner worked like this:\nLoad a track off the disk Call the database to find out if the track\u0026rsquo;s artist or album exists yet If they do, update their info to include the new track, otherwise create new artist / album Insert all the new info into the dabase Repeat for each track The new scanner has multiple passes:\nLoad tracks Read track info off the disk Create a track object and add into a thread safe List (more on that later) Fill out database objects Create album objects based on found tracks Create artist objects based on found tracks Update track info to link to new album and artists objects Upload to database Uploads all the in memory info into the database Delete Remove tracks, albums, artists that are missing from the disk Keeping things in memory sped things up a ton. For the 4607 files on my SSD, it takes about 10-15 seconds. The old scanner took around 3 minutes 30 seconds. I was also able to enable loading multiple files at a time with the thread-safe ConcurrentDictionary type. Super useful, but only really works on my SSD. On the HDD it takes longer to load in the file, so the threads get backed up (to a max of 25).\nOnly a few more things to do for the scanner now. I plan on adding genre merging, because I have a lot of tracks that have genres like Drum and Bass, Drum n Bass, DnB, where they are all the same genre, just written down differently. But they show up as two different genres in the db. So I\u0026rsquo;d like a way to \u0026ldquo;Canonicalize\u0026rdquo; genres into one.\nScanner V2 Demo ","date":"2024-03-08T00:00:00Z","image":"https://epsirho.com/p/mms-dl2/ScannerBanner_hua6991f5b2e4f7b25d1b61f5f043ca3b9_49990_120x120_fill_box_smart1_3.png","permalink":"https://epsirho.com/p/mms-dl2/","title":"Melon Media Server Devlog 2"},{"content":"For the last 2 years I\u0026rsquo;ve been acquiring songs I like in as high quality as I can find and saving them locally. I wanted to have my own stash of music so I wouldn\u0026rsquo;t loose access to the songs that mean the most to me. I\u0026rsquo;ve been using Plex to listen to my local library ever since, but Plex has so many issues that bother me. I\u0026rsquo;ve looked into other options like Jellyfin, but all the big media servers seem to have tacked on music as an after thought. I want it to be better and I want more control. So now I\u0026rsquo;m making Melon, the music focused media player.\nThis project started in May of 2023, with an experimental scanner. I toyed with lots of options for databases, along with what to store and how. I ended up with MongoDB, as it\u0026rsquo;s json-like document system is super powerful for this use case. The Melon Scanner combs recursively through the folders you specify logging every music file and .lrc file. It gets the track information from the music file metadata, so you\u0026rsquo;ll want to use a tool like MusicBrainz Picard. MusicBrainz\u0026rsquo;s data is what I\u0026rsquo;m modeling off of, so support for it\u0026rsquo;s metadata tags will be in Melon. Below is an example of a Track in the db.\nAfter getting it mostly working (it didn\u0026rsquo;t actually, I\u0026rsquo;ve had to fix that scanner code a million times later) I created a nice UI to allow for initial setup and control of the database. This UI has gone through many stages but I\u0026rsquo;m really happy with the current result. A headless mode also exists now if you don\u0026rsquo;t want to run with the UI.\nI\u0026rsquo;ve since started learning ASP.NET and creating a web API for clients to interact with. I\u0026rsquo;ve got lots of work done, and most of the main endpoints such as search, playlists, and play statistics are all pretty much done. But i\u0026rsquo;ve got quite a few more things to finish. Currently I\u0026rsquo;m working on endpoints to allow updating track/album/artist info, but I\u0026rsquo;ve also got endpoints like recommendations, ratings, and user friending to get done. The project is awhile off, probably a few more months to finish the server.\nI plan on creating a Windows and iOS application for v1 release. I\u0026rsquo;d also like other Apple device apps like MacOS and tvOS. I don\u0026rsquo;t own an android phone, so I\u0026rsquo;m not creating an app for it myself. A friend of mine has been working on one at the same time as I\u0026rsquo;m creating the server, which has been a huge help in testing and modeling how things will work. In the end, I want it to be accessible for any developer to make apps for melon if they\u0026rsquo;d like.\nAll my previous projects have been open source and free, however I\u0026rsquo;m trying to think of a good way to make some money from this project. It\u0026rsquo;s taken so much effort and I\u0026rsquo;m really proud of it, and I think it\u0026rsquo;ll be worth the price. So the plan right now is the Melon server code will be open and anyone can grab a build of the server to spin up themselves, but the apps will either be paid, have a free trial, or have some features locked behind a pro version. I\u0026rsquo;ve thought about making the code for the apps open too, so if you don\u0026rsquo;t want to pay or just want to try it out first, you can build it yourself. I\u0026rsquo;m not set on any of these ideas, nor the price. I do know that it will NOT be a subscription, just a one time payment.\nI\u0026rsquo;ll talk more about features and pricing when the time comes. I mostly wanted to make this blog post to show I\u0026rsquo;m alive and working on something big. I\u0026rsquo;ll likely post more devlogs here and there, and I\u0026rsquo;ll announce on my socials when it\u0026rsquo;s time for release!\n","date":"2024-01-24T00:00:00Z","image":"https://epsirho.com/p/mms-dl1/mms-3_hud51950628a2c2f5ebf6072930dfc4735_179512_120x120_fill_box_smart1_3.png","permalink":"https://epsirho.com/p/mms-dl1/","title":"Melon Media Server Devlog 1"},{"content":"Recently, inspired by the lack of an open source codebase for Everything and some discussion with some devs on discord, I started a project I call Momentum. It was originally planned for UWP, to be a file indexer and search that had a modern Windows 11 look and feel. However, I found some weird issues while working on the indexer code.\nConsole code I started development on the indexer and search functions, which I programmed in a C# Console Application. The first goal was simple, create a performant indexer using hash tables and json. A simple Dictionary\u0026lt;string, string\u0026gt; was used first, but later became a Dictionary\u0026lt;string, IndexedFileInfo\u0026gt;.\nIndexer code Recursively scan through every folder from x starting point. Handle exceptions thrown by folders who block access. Return one filled dictionary with all files and folders scanned. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 public static void IndexFiles() { var dictionary = SearchDirectory(\u0026#34;C:\\\\Users\\\\jhset\\\\Pictures\u0026#34;); Display.Message = \u0026#34;Saving to File\u0026#34;; SaveIndexesToFile(dictionary); } private static Dictionary\u0026lt;string, List\u0026lt;IndexedFileInfo\u0026gt;\u0026gt; SearchDirectory(string path) { var dictionary = new Dictionary\u0026lt;string, List\u0026lt;IndexedFileInfo\u0026gt;\u0026gt;(); try { // Get directories in path var dirs = Directory.GetDirectories(path); // If ther are dirs, recursively check them if (dirs.Length \u0026gt; 0) { foreach (var dir in dirs) { var ret = SearchDirectory(dir); foreach (var f in ret) { if (dictionary.ContainsKey(f.Key)) { foreach (var s in f.Value) { dictionary[f.Key].Add(s); } } else { dictionary.Add(f.Key, new List\u0026lt;IndexedFileInfo\u0026gt;(f.Value)); } } } } // Get the files in this dir var files = Directory.GetFiles(path); // Add each file to dictionary foreach (var file in files) { string name = file.Split(\u0026#34;\\\\\u0026#34;).Last().ToLower(); var list = new List\u0026lt;IndexedFileInfo\u0026gt;(); list.Add(new IndexedFileInfo() { Icon = \u0026#34;\u0026amp;#xE130;\u0026#34;, Path = file}); if (dictionary.ContainsKey(name)) { foreach (var s in list) { dictionary[name].Add(s); } } else { dictionary.Add(name, list); } } // Finally, add this folder to the dictionary string foldername = path.Split(\u0026#39;\\\\\u0026#39;).Last().ToLower(); var flist = new List\u0026lt;IndexedFileInfo\u0026gt;(); flist.Add(new IndexedFileInfo() { Icon = \u0026#34;\u0026amp;#xE8B7;\u0026#34;, Path = path }); Display.IndexedFolders++; if (dictionary.ContainsKey(foldername)) { dictionary[foldername].Add(new IndexedFileInfo() { Icon = \u0026#34;\u0026amp;#xE8B7;\u0026#34;, Path = path }); } else { dictionary.Add(foldername, flist); } } catch (Exception ex) { Display.TotalErrored++; return new Dictionary\u0026lt;string, List\u0026lt;IndexedFileInfo\u0026gt;\u0026gt;(); } return dictionary; } Saving code Serialize the dictionary to json Save to a file. 1 2 3 4 5 6 private static void SaveIndexesToFile(Dictionary\u0026lt;string, List\u0026lt;IndexedFileInfo\u0026gt;\u0026gt; dictionary) { string text = JsonConvert.SerializeObject(dictionary, Formatting.Indented); File.WriteAllText(\u0026#34;C:\\\\Users\\\\jhset\\\\Desktop\\\\Index.json\u0026#34;, text); } Loading code Load file in as string Deserialize json to dictionary 1 2 3 4 5 6 7 8 9 10 11 12 13 14 public static Dictionary\u0026lt;string, List\u0026lt;IndexedFileInfo\u0026gt;\u0026gt; LoadIndexesFromFile() { try { string text = File.ReadAllText(\u0026#34;C:\\\\Users\\\\jhset\\\\Desktop\\\\Index.json\u0026#34;); var obj = JsonConvert.DeserializeObject\u0026lt;Dictionary\u0026lt;string, List\u0026lt;IndexedFileInfo\u0026gt;\u0026gt;\u0026gt;(text); return obj; } catch (Exception) { return null; } } Searching code Search dictionary for results containing x Display. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 var list = files.Where(o =\u0026gt; o.Key.Contains(input)).ToList(); for(int i = 0; i \u0026lt; 15; i++) { try { foreach (var line in list[i].Value) { Console.WriteLine($\u0026#34;{list[i].Key}\u0026#34;); } } catch (Exception) { } } Results The results of this first test were good, really good. Better than I was expecting. The test set was my C Drive, a Samsung SSD 970 EVO 1TB. Each test indexed 1,575,799 files. The inital console test was great, and brought in an indexing time of 70 seconds and saving time of 5 seconds.\nMoving to a proper UI I wanted to move this project to a UI framework, initally I wanted it to be UWP because mica isn\u0026rsquo;t available in the WinUI 3 yet. So I get to work developing a simple UI and porting over the code. With the BroadFilesystemAccess capability enabled, the code for the file indexer could be exactly the same. I started running the first test and.. why is it so slow?\nI looked back and forth. \u0026ldquo;No, the code is the same!\u0026rdquo; I tried disabling the UI that shows the current ammount of files indexed and elpased time since start. No, still not done after waiting 10 minutes. It\u0026rsquo;s not just slow, it\u0026rsquo;s SLOW. So now I need to check something\nWPF and the WASDK So I created two other projects with simple UIs, and ported the code over.\nNot bad, WASDK came out a bit slower but otherwise not bad. So you\u0026rsquo;re probably thinking \u0026ldquo;Well where\u0026rsquo;s UWP\u0026rsquo;s times?\u0026rdquo;\nAh. Thats 3 hours, 31 minutes, and 41 seconds. So, what the fuck?\nSadly, I don\u0026rsquo;t have a good answer for this. My assumption is that the sandbox model causes file access to take more time. It sucks that even with the BroadFileSystem capability UWP\u0026rsquo;s file access is so slow.\nSo I decided to move to the WASDK. Goodbye Mica, my beloved. This transition wasn\u0026rsquo;t without issues either. When saving and loading I encountered a System.OutOfMemoryException. This only happened here, I don\u0026rsquo;t have a good answer for why, but I had to design around it.\nNew saving code 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 private static void SaveIndexesToFile(Dictionary\u0026lt;string, List\u0026lt;IndexedFileInfo\u0026gt;\u0026gt; dictionary) { string path = Environment.GetFolderPath(Environment.SpecialFolder.MyDocuments); string[] dirs = Directory.GetDirectories(path); if (!dirs.Contains(\u0026#34;Momentum\u0026#34;)) { System.IO.Directory.CreateDirectory($\u0026#34;{path}\\\\Momentum\u0026#34;); } StreamWriter sw = File.CreateText($\u0026#34;{path}\\\\Momentum\\\\Index.json\u0026#34;); JsonTextWriter writer = new JsonTextWriter(sw); writer.Formatting = Formatting.Indented; writer.WriteStartObject(); Files = new ConcurrentDictionary\u0026lt;string, List\u0026lt;IndexedFileInfo\u0026gt;\u0026gt;(); foreach (var item in dictionary) { Files.TryAdd(item.Key, item.Value); writer.WritePropertyName(item.Key); writer.WriteStartArray(); foreach (var file in item.Value) { writer.WriteStartObject(); writer.WritePropertyName(\u0026#34;Name\u0026#34;); writer.WriteValue(item.Key); writer.WritePropertyName(\u0026#34;Path\u0026#34;); writer.WriteValue(file.Path); writer.WritePropertyName(\u0026#34;Icon\u0026#34;); writer.WriteValue(file.Icon); writer.WriteEndObject(); } writer.WriteEndArray(); sw.Flush(); } writer.WriteEndObject(); writer.Flush(); writer.Close(); } New loading code 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 public static async void LoadIndexesFromFile() { try { IsFullyLoaded = false; Files = new ConcurrentDictionary\u0026lt;string, List\u0026lt;IndexedFileInfo\u0026gt;\u0026gt;(); string p = Environment.GetFolderPath(Environment.SpecialFolder.MyDocuments); string[] dirs = Directory.GetDirectories(p); if (!dirs.Contains(\u0026#34;Momentum\u0026#34;)) { System.IO.Directory.CreateDirectory($\u0026#34;{p}\\\\Momentum\u0026#34;); } StreamReader sr = File.OpenText($\u0026#34;{p}\\\\Momentum\\\\Index.json\u0026#34;); JsonTextReader reader = new JsonTextReader(sr); while (reader.Read()) { if (reader.Value != null) { var item = new KeyValuePair\u0026lt;string, List\u0026lt;IndexedFileInfo\u0026gt;\u0026gt;(); reader.Read(); reader.Read(); while (true) { reader.Read(); reader.Read(); string name = reader.Value.ToString(); reader.Read(); reader.Read(); string path = reader.Value.ToString(); reader.Read(); reader.Read(); string icon = reader.Value.ToString(); reader.Read(); reader.Read(); if (Files.ContainsKey(name)) { Files[name].Add(new IndexedFileInfo() { Name = name, Path = path, Icon=icon }); } else { var lst = new List\u0026lt;IndexedFileInfo\u0026gt;(); lst.Add(new IndexedFileInfo() { Name = name, Path = path, Icon = icon }); Files.TryAdd(name, lst); } if (reader.TokenType == JsonToken.EndArray) { break; } } } } IsFullyLoaded = true; //var obj = JsonReader .DeserializeObject\u0026lt;Dictionary\u0026lt;string, List\u0026lt;IndexedFileInfo\u0026gt;\u0026gt;\u0026gt;(text); //Files = obj; } catch (Exception) { return; } } The new loading code is cool because the application can now load in files while you search, so the user can search before the full index file is done loading. This is nice because larger index files can take a few seconds to load.\nWASDK and the final application As much as I\u0026rsquo;ll miss mica, the WASDK is nice to use. If you\u0026rsquo;re coming from UWP, you\u0026rsquo;ll be right at home. Only a few things differ, but the XAML code is mostly the same.\nIf you want to test the application out and see the full source code, check out the GitHub Repository!\n","date":"2022-03-20T00:00:00Z","image":"https://epsirho.com/p/momentum-uwp-blog/momentum-3_hu38e52a46fab48fc3ea7a06c7c6dfd5b3_124690_120x120_fill_box_smart1_3.png","permalink":"https://epsirho.com/p/momentum-uwp-blog/","title":"Momentum and file performance quirks in UWP"},{"content":"This is a small little application to view the information stored in a Discord Data Package. This is to help users easily explore the data discord has on them, as it can be hard for normal users to comb through large text and json files.\nYou can find the code and download on GitHub\nUpdate: Pushed v1.0.1 to fix an odd COM related crash in newer Win11 versions.\n","date":"2022-02-13T00:00:00Z","image":"https://epsirho.com/p/discord-dpe/ddpe_huf00df9781f4fa4121d4b1b57fd0408ab_289591_120x120_fill_box_smart1_3.png","permalink":"https://epsirho.com/p/discord-dpe/","title":"Discord Data Package Explore"},{"content":"A beautiful, native windows app for e926/e621! View, search, and download posts submitted by other users, and submit your own.\nThis was a fun project I used to deep dive into learning UWP and making better UIs. It got pretty far along, but I\u0026rsquo;ll likely no longer be updating it. It does still mostly work despite a few bugs, I may go fix them at some point but I don\u0026rsquo;t plan to. I\u0026rsquo;m pretty proud of the result, especially the custom control behavior I made for the upload page.\nIf you want to check this out, it\u0026rsquo;s availible on GitHub and the Microsoft Store. Don\u0026rsquo;t worry, it starts in safe mode! You have to enable NSFW content in the settings if that\u0026rsquo;s what you\u0026rsquo;re looking for :P\n","date":"2022-02-13T00:00:00Z","image":"https://raw.githubusercontent.com/EpsiRho/Fluff/main/1.png","permalink":"https://epsirho.com/p/fluff/","title":"Fluff"},{"content":"I made this project cause I was having fun with wordle and wanted to play more than once a day. It\u0026rsquo;s pretty simple, works the same as the Wordle website does.\nThe code and downloaded are both up on GitHub.\n","date":"2022-01-09T00:00:00Z","image":"https://epsirho.com/p/wordle/wordle_hub417329461023081bc04acd6602073e7_17349_120x120_fill_box_smart1_3.png","permalink":"https://epsirho.com/p/wordle/","title":"Wordle Offline"},{"content":"This was made while I was learning REST API development for the first time. I picked the e621 API for the funny and because it\u0026rsquo;s auth and rate-limits were relaxed and easy to start with. This later went on to be used in Fluff, which was my first attempt at a good looking UI application. I hosted it on nuget to make it easier to use in my projects, and for some reason it has 11k+ downloads xP\nYou can find the code on GitHub and the built library on nuget. Documentation for this is incomplete and I\u0026rsquo;ll likely not revisit it!\n","date":"2021-03-19T00:00:00Z","permalink":"https://epsirho.com/p/e621-library/","title":"E621 C# Library"},{"content":"This was the first real app I developed. I started the project because at the time, Discord\u0026rsquo;s upload limit was 8mb and that was never enough to send files to my friends. So I created horizon to give me infinite upload limit and allow easy transfers to my contacts.\nCheck it out on GitHub or the Microsoft Store.\n","date":"2020-12-28T00:00:00Z","image":"https://epsirho.com/p/horizon/horizon_hu0b7590dc8e23bf018df66f53a7755f93_261473_120x120_fill_box_smart1_3.png","permalink":"https://epsirho.com/p/horizon/","title":"Horizon File Transfer"},{"content":"This was a fun project I worked on to help me prototype console tools quicker and allow me to make them look and feel nice. I worked on it from Sept 2020 to Feb 2021. It was made for windows, and while some features might work on other operating systems a few will certainly not, such as the cursor menu.\nFull documentation is available as well as a demo application that showcases many of the features. You can find both of those things on the Github Repo.\n","date":"2020-09-16T00:00:00Z","permalink":"https://epsirho.com/p/cppuikit/","title":"C++ UIKit"}]