
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Audio Visualizations in C#</title>
    <link rel="icon" type="image/x-icon" href="/images/favicon.ico">
    <link rel="stylesheet" href="/styles/main.css">
    <link rel="stylesheet" href="/styles/posts.css">
    <link rel="stylesheet" href="/styles/fvz.css">
</head>
<body>
    <div class="container">
        <aside class="sidebar">
            <div class="profile">
                <img src="/images/pfp.png" alt="Profile" class="profile-img">
                <h1 class="profile-name">Epsi's Den</h1>
                <p class="profile-bio">Software developer, Lava lamp dog, totally a professional</p>
                <div class="social-links">
                    <a href="https://bsky.app/profile/epsirho.com" aria-label="Bluesky" class="social-link">
                        <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-brand-bluesky" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
                            <path stroke="none" d="M0 0h24v24H0z" fill="none"></path>
                            <path d="M6.335 5.144c-1.654 -1.199 -4.335 -2.127 -4.335 .826c0 .59 .35 4.953 .556 5.661c.713 2.463 3.13 2.75 5.444 2.369c-4.045 .665 -4.889 3.208 -2.667 5.41c1.03 1.018 1.913 1.59 2.667 1.59c2 0 3.134 -2.769 3.5 -3.5c.333 -.667 .5 -1.167 .5 -1.5c0 .333 .167 .833 .5 1.5c.366 .731 1.5 3.5 3.5 3.5c.754 0 1.637 -.571 2.667 -1.59c2.222 -2.203 1.378 -4.746 -2.667 -5.41c2.314 .38 4.73 .094 5.444 -2.369c.206 -.708 .556 -5.072 .556 -5.661c0 -2.953 -2.68 -2.025 -4.335 -.826c-2.293 1.662 -4.76 5.048 -5.665 6.856c-.905 -1.808 -3.372 -5.194 -5.665 -6.856z"></path>
                        </svg>
                    </a>
                    <a href="https://github.com/EpsiRho" aria-label="GitHub" class="social-link">
                        <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-brand-github" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
                            <path stroke="none" d="M0 0h24v24H0z" fill="none"></path>
                            <path d="M9 19c-4.3 1.4 -4.3 -2.5 -6 -3m12 5v-3.5c0 -1 .1 -1.4 -.5 -2c2.8 -.3 5.5 -1.4 5.5 -6a4.6 4.6 0 0 0 -1.3 -3.2a4.2 4.2 0 0 0 -.1 -3.2s-1.1 -.3 -3.5 1.3a12.3 12.3 0 0 0 -6.2 0c-2.4 -1.6 -3.5 -1.3 -3.5 -1.3a4.2 4.2 0 0 0 -.1 3.2a4.6 4.6 0 0 0 -1.3 3.2c0 4.6 2.7 5.7 5.5 6c-.6 .6 -.6 1.2 -.5 2v3.5"></path>
                          </svg>
                    </a>
                    <a href="https://furry.engineer/@epsi" aria-label="Mastodon" class="social-link">
                        <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-brand-mastodon" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
                            <path stroke="none" d="M0 0h24v24H0z" fill="none"></path>
                            <path d="M18.648 15.254c-1.816 1.763 -6.648 1.626 -6.648 1.626a18.262 18.262 0 0 1 -3.288 -.256c1.127 1.985 4.12 2.81 8.982 2.475c-1.945 2.013 -13.598 5.257 -13.668 -7.636l-.026 -1.154c0 -3.036 .023 -4.115 1.352 -5.633c1.671 -1.91 6.648 -1.666 6.648 -1.666s4.977 -.243 6.648 1.667c1.329 1.518 1.352 2.597 1.352 5.633s-.456 4.074 -1.352 4.944z"></path><path d="M12 11.204v-2.926c0 -1.258 -.895 -2.278 -2 -2.278s-2 1.02 -2 2.278v4.722m4 -4.722c0 -1.258 .895 -2.278 2 -2.278s2 1.02 2 2.278v4.722"></path>
                        </svg>
                    </a>
                </div>
            </div>
            <nav>
                <ul class="nav-menu">
                    <li class="nav-item">
                        <a href="/" class="nav-link">
                            <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-home" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
                                <path stroke="none" d="M0 0h24v24H0z"></path>
                                <polyline points="5 12 3 12 12 3 21 12 19 12"></polyline>
                                <path d="M5 12v7a2 2 0 0 0 2 2h10a2 2 0 0 0 2 -2v-7"></path>
                                <path d="M9 21v-6a2 2 0 0 1 2 -2h2a2 2 0 0 1 2 2v6"></path>
                              </svg>
                            Home
                        </a>
                    </li>
                    <li class="nav-item">
                        <a href="/site/about" class="nav-link">
                            <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-user-square" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M9 10a3 3 0 1 0 6 0a3 3 0 0 0 -6 0"></path><path d="M6 21v-1a4 4 0 0 1 4 -4h4a4 4 0 0 1 4 4v1"></path><path d="M3 5a2 2 0 0 1 2 -2h14a2 2 0 0 1 2 2v14a2 2 0 0 1 -2 2h-14a2 2 0 0 1 -2 -2v-14z"></path>
                            </svg>
                             About
                            </a>
                    </li>
                    <li class="nav-item">
                        <a href="/site/posts" class="nav-link">
                            <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-layout-dashboard" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M4 4h6v8h-6z"></path><path d="M4 16h6v4h-6z"></path><path d="M14 12h6v8h-6z"></path><path d="M14 4h6v4h-6z"></path></svg>
                             Blog Posts
                        </a>
                    </li>
                    <li class="nav-item">
                        <a href="/site/projects" class="nav-link">
                            <svg xmlns="http://www.w3.org/2000/svg"  width="24"  height="24"  viewBox="0 0 24 24"  fill="none"  stroke="currentColor"  stroke-width="2"  stroke-linecap="round"  stroke-linejoin="round"  class="icon icon-tabler icons-tabler-outline icon-tabler-code"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M7 8l-4 4l4 4" /><path d="M17 8l4 4l-4 4" /><path d="M14 4l-4 16" /></svg>
                             Projects
                        </a>
                    </li>
                    <li class="nav-item">
                        <a href="/site/music" class="nav-link">
                            <svg  xmlns="http://www.w3.org/2000/svg"  width="24"  height="24"  viewBox="0 0 24 24"  fill="none"  stroke="currentColor"  stroke-width="2"  stroke-linecap="round"  stroke-linejoin="round"  class="icon icon-tabler icons-tabler-outline icon-tabler-music"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M3 17a3 3 0 1 0 6 0a3 3 0 0 0 -6 0" /><path d="M13 17a3 3 0 1 0 6 0a3 3 0 0 0 -6 0" /><path d="M9 17v-13h10v13" /><path d="M9 8h10" /></svg>
                             Music Recommendations
                        </a>
                    </li>
                </ul>
            </nav>
        </aside>

        <main class="main-content">
            <article class="blog-post-page">
                <img src="/images/fftblogheader.png" alt="Blog Header" class="post-header-image">
                </br>
                <span class="post-tag"> C#</span>
<span class="post-tag"> Audio</span>
<span class="post-tag"> Melon</span>
<span class="post-tag"> Windows</span>

                <h1 class="post-title" id="mdpost-title">Audio Visualizations in C#</h1>
                <p class="post-description">Experimenting with real time and generated audio visualizations</p>
                <div class="post-date">6/24/2025 12:00:00 AM</div>
                <div class="post-body" id="post-page">
                    <p>Hey everyone! I've been busy as I move towards graduating this December. But I'm gearing up for some of the final features I want in Melon v1.0. The last main features I'm tracking are:</p>
<ul>
<li> Swap out Old UI system for MelonUI library</li>
<ul>
<li> Waiting on two last things for MelonUI</li>
</ul>
<li> Genre Canonicalization</li>
<ul>
<li> Waiting on the new Discovery system</li>
</ul>
<li> The new Discovery system</li>
<ul>
<li> Hoping to work on this as my senior project in my last semester. I've pulled together lots of stuff for it but haven't started work on it (cause I'm not allowed to if I want it to be that project)</li>
</ul>
<li> Visualizations</li>
<ul>
<li> What I'm here to talk about today!</li>
</ul>
</ul>
</br>
<p>A big idealistic view for Melon's development is that it should be easy for developers interfacing with the server to be able to implement features and reach parity with other clients. Melon will try and handle as much of the implementation and processing that it can to make clients easier to build and make them work on more devices.</p>
</br>
<p>Melon already has a visualization feature built in, under api/download/track-waveform you can get a waveform of the whole track. The planned use in clients is to show the waveform as the playback progress bar. It's fast to compute and small to send to clients so this was an easy one to implement. It's not the only visualization feature I want though.</p>
</br>
<p>I'm a big fan of frequency visualizers, and have been using many like the Fountain of Colors with Rainmeter over the years. I have recently gone back to that one in 2025 on Windows 11 and its... a highly degraded experience (if working at all, I had menus that would set their values to -1 if you interacted with them at all, breaking the visualizer). This prompted me to look around for other systems like it and not find any that were as customizable. So I went and started work on my own! Using C# + WPF for the app and UI, <a href="https://github.com/naudio/NAudio">NAudio</a> for WASAPI access, and <a href="https://github.com/naudio/NAudiohttps://github.com/swharden/FftSharp">FFTSharp</a> for it's way better implementation of the Fast Fourier Transform than mine. The app flow is simple in theory but a bit messy. It simply takes in float data from the WASAPI and builds frames to put in a queue that the UI can pull from and display. I'll go over how that works below, with some summaries and then more detailed comments.</p>
</br>
<h1 id="mdheadr--FFT-Visualization-Pipeline-Code"> FFT Visualization Pipeline Code</h1>
</br>
<h2 id="mdheadr--Getting-Audio"> Getting Audio</h2>
<p>We need to get a few things before we can build frames for our visualizer. First, get audio bytes from our source (in this case WASAPI Capture), then convert those into float samples.</p>
</br>
<p>This is our <b>starting function</b>. It sets up our variables and starts recording on the selected device, if any. It supports routing based on Output device, Input device, or PID for a selected process capture.</p>
<pre class="code-block">
<code>
WasapiLoopbackCapture _capture;  
WaveFormat _CaptureFormat;       
WasapiCapture _inputCapture; 
// Checking if this is an input device or an output device
if (!isInput)
{
    var devEnum = new MMDeviceEnumerator(); // Audio Device enumerator
    
    // If no selected audio device setup with the default
    if (_audioDevice == null)
    {
        _capture = new WasapiLoopbackCapture();
        _CaptureFormat = _capture.WaveFormat;
    }
    else // Otherwise we need to setup a new capture using the selected device
    {
        MMDevice output = string.IsNullOrWhiteSpace(_audioDevice.FriendlyName)
            ? devEnum.GetDefaultAudioEndpoint(DataFlow.Render, Role.Console)
            : devEnum.EnumerateAudioEndPoints(DataFlow.Render, DeviceState.Active)
                      .First(d => d.FriendlyName == _audioDevice.FriendlyName);
        
        _capture = new WasapiLoopbackCapture(output);
        _CaptureFormat = _capture.WaveFormat;
    }
}
else // Same thing as above, except for Microphone inputs (DataFlow.Capture vs DataFlow.Render)
{
    var devEnum = new MMDeviceEnumerator();
    MMDevice mic = string.IsNullOrWhiteSpace(_audioDevice.FriendlyName)
        ? devEnum.GetDefaultAudioEndpoint(DataFlow.Capture, Role.Console)
        : devEnum.EnumerateAudioEndPoints(DataFlow.Capture, DeviceState.Active)
                  .First(d => d.FriendlyName == _audioDevice.FriendlyName);
    _inputCapture = new WasapiCapture(mic);
    _CaptureFormat = _inputCapture.WaveFormat;
}

// Selected app variable used to allow users to select per-process audio 
// This functionality as of this publication is NOT in NAudio, see "WASAPI Woes" section below.
if (SelectedApp != "")
{
    int pid = int.Parse(SelectedApp.Split(" - ")[0]);
    var cap = await WasapiCapture.CreateForProcessCaptureAsync(pid, true);
    _CaptureFormat = cap.WaveFormat;
    
    cap.DataAvailable += CaptureOnDataAvailable;
    cap.StartRecording();
    
    while (!token.IsCancellationRequested) { }
    cap.StopRecording();
}
else if (!isInput) // Output device 
{
    _capture.DataAvailable += CaptureOnDataAvailable; // Hook Capture function to event that's called when data is ready
    _capture.StartRecording(); // Start Recording
    while (!token.IsCancellationRequested) { }
    _capture.StopRecording();
}
else // Input device
{
    _inputCapture.DataAvailable += CaptureOnDataAvailable; // Hook Capture function to event that's called when data is ready
    _inputCapture.StartRecording(); // Start Recording
    while (!token.IsCancellationRequested) { }
    _inputCapture.StopRecording();
}
</code>
</pre>
</br>
<p>Next we have to do something with that data. Here I would just convert from the bytes given by the WASAPI to the float samples I need, however when getting audio per-process it returns in PCM-16 rather than Float (more on that later). So I have two paths to take for transforming the bytes into samples. We also want to use a ring buffer / circular buffer to store both the bytes and the samples given to use. At first I used just a buffer to store the incoming bytes, which would never fill the buffer to the needed size in one go. This would mean we have to wait multiple calls before it's ready to build a frame with, and makes the visualization look laggy. First we store the bytes in the ring buffer so we can continually decode samples, where the first byte is the oldest in the buffer and gets pushed out when a new one is added. Once the buffer fills to the needed limit for the first time the visuals can continually decode samples for running FFT. The CircularBuffer implementation comes from <a href="https://github.com/joaoportela/CircularBuffer-CSharp/blob/master/CircularBuffer/CircularBuffer.cs">this lovely repo</a>, though I have also extended it to support thread safety.</p>
<pre class="code-block">
<code>
private static void CaptureOnDataAvailable(object? sender, WaveInEventArgs e)
{
    if (MainWindow.FVZMode) return; // Disables live playback when playing fvz files (more on that later)

    try
    {
        var fmt = _CaptureFormat;

        // Calculate buffer size
        int samplesNeeded = InstanceOptions._fftSize / fmt.Channels;
        int bytesPerSample = fmt.BitsPerSample / 8;
        int bufferSizeInBytes = samplesNeeded * fmt.Channels * bytesPerSample;

        if (tempBuffer.Capacity != bufferSizeInBytes)
        {
            tempBuffer = new CircularBuffer<byte>(bufferSizeInBytes);
        }

        // Add new data to buffer
        for (int i = 0; i < e.BytesRecorded; i++)
        {
            tempBuffer.PushBack(e.Buffer[i]);
        }

        // Check if we have enough data
        if (tempBuffer.Count() < bufferSizeInBytes)
        {
            return;
        }

        // Extract bytes from the ring buffer
        byte[] buffer = new byte[bufferSizeInBytes];
        int idx = 0;
        foreach (var b in tempBuffer)
        {
            buffer[idx++] = b;
            if (idx >= bufferSizeInBytes) break;
        }

        // Process bytes into samples
        if (fmt.Encoding == WaveFormatEncoding.IeeeFloat ||
            (fmt.Encoding == WaveFormatEncoding.Extensible &&
             ((WaveFormatExtensible)fmt).SubFormat == AudioMediaSubtypes.MEDIASUBTYPE_IEEE_FLOAT))
        {
            ProcessFloatData(buffer, bufferSizeInBytes, fmt, samplesNeeded);
        }
        else if (fmt.Encoding == WaveFormatEncoding.Pcm && fmt.BitsPerSample == 16)
        {
            ProcessPcm16Data(buffer, bufferSizeInBytes, fmt, samplesNeeded);
        }
    }
    catch (Exception ex)
    {
    
    }
}
</code>
</pre>
</br>
<p>Depending on which path is taken one of the following functions is run. Either way on the other side we'll have samples ready for FFT processing. For float samples we get 4 bytes per sample, but when in stereo 2 channel mode it alternates between left and right samples, which we just want to average here for mono visualizations (although 2 channel visualizations could look cool as well, and I may look into supporting this later). Then we push these samples into another CircularBuffer, so that the FFT thread can continuously build frames asap.</p>
<pre class="code-block">
<code>
private static void ProcessFloatData(byte[] buffer, int bytesRecorded, WaveFormat fmt, int needed)
{
// Since data is already floats we can cast it from the bytes to a float as given
    ReadOnlySpan<float> span = MemoryMarshal.Cast<byte, float>(buffer.AsSpan(0, bytesRecorded));
    int channels = fmt.Channels;

    if (channels == 2)
    {
	    // Stereo
        for (int n = 0; n < needed; n++)
        {
            int i = n * 2;
            _samples.PushBack((span[i] + span[i + 1]) * 0.5f);
        }
    }
    else
    {
        // Mono
        for (int n = 0; n < needed - 1; n++)
        {
            _samples[n] = span[n * channels];
            _samples.PushBack(span[n * channels]);
        }
    }
}
</code>
</pre>
</br>
<p>For PCM-16 it's very similar, but it uses shorts instead of floats:</p>
<pre class="code-block">
<code>
private static void ProcessPcm16Data(byte[] buffer, int bytesRecorded, WaveFormat fmt, int needed)
{
    // Same byte cast but to shorts instead
    ReadOnlySpan<short> span = MemoryMarshal.Cast<byte, short>(buffer.AsSpan(0, bytesRecorded));
    int channels = fmt.Channels;

    const float scale = 1.0f / 32768f;

    if (channels == 2)
    {
        // Stereo
        for (int n = 0; n < needed; n++)
        {
            int i = n * 2;
            _samples.PushBack(((span[i] + span[i + 1]) * 0.5f) * scale);
        }
    }
    else
    {
        // Mono
        for (int n = 0; n < needed; n++)
        {
            _samples.PushBack(span[n * channels] * scale);
        }
    }
}

</code>
</pre>
</br>
<h2 id="mdheadr--Getting-Visualizer-Frames"> Getting Visualizer Frames</h2>
<p>Now we have usable samples to pass through the Fast Fourier Transform.</p>
<pre class="code-block">
<code>
private static void ComputeFFT(int needed)
{
	// Get the sample rate
    int sampleRate = _CaptureFormat.SampleRate;
    while (!_fftCTS.IsCancellationRequested)
    {
        fpsMeter.StartFpsCounter();
        
	    // Make sure the sample buffer is read (and we aren't in FVZ Mode)
        if (!_samples.IsFull || _samples.IsEmpty || MainWindow.FVZMode)
        {
            fpsMeter.StopFpsCounter();
            continue;
        }
        try
        {
            // Apply window function using FFTSharp
            var slice = _samples.ToArray();
            _window.ApplyInPlace(slice);

            // FFT processing using FFTSharp
            _spectrum = FFT.Forward(slice);
            _magnitudes = FFT.Magnitude(_spectrum);

            // Build frame with current scale mode
            BuildFrame(_magnitudes, sampleRate);
        }
        catch (Exception)
        {

        }
        fpsMeter.StopFpsCounter();
    }
}
</code>
</pre>
</br>
<p>BuildFrame routes to different representations of the frequency spectrum, selected in the UI. I want to cover two of the spectrums, Log10 and "Normalized". There is also support for the Mel spectrogram binning.</p>
</br>
<p>First, Log10. This function takes our magnitudes from the last step and averages them into bars that we will display on the visualizer. If it were just linear, we would find how many bins fit in how many bars equally splitting the bins into each bar, but human hearing doesn't work that way. Our pitch perception is said to be logarithmic, where each octave doubles in frequency. So we can double each section of bins, like so: 20-40, 40-80, 80-160, 160-320, etc. This means high frequency bins get shoved into less bars.</p>
<pre class="code-block">
<code>
private static void BuildFrameLogNormalized(double[] mags, int sampleRate)
{
	// Preparing Variables
    double fMin = InstanceOptions._fMin;
    double fMax = InstanceOptions._fMax == -1 ? sampleRate / 2.0 : InstanceOptions._fMax;
    int rows = InstanceOptions._bars;
    var power = new double[rows]; // Stores Accumulated Power sums for each bar
    var binCnt = new double[rows]; // Stores count of FFT bins -> Visualizer bins
	
    // Logarithmic edges 
    // Human hearing is said to be logarithmic, so we compensate by making the spectrum of frequencies take up more space as you get higher up. 
    // This means at the low end a bar might be 20-40, but higher up will be 1600-3200. By contrast Linear would take the same ammount of fft bins into each visualizer bar, 20-40 at the bottom and 1600-1620 at the top.
    double logMin = Math.Log10(fMin);
    double logMax = Math.Log10(fMax);
    double logStep = (logMax - logMin) / rows;

    // Pre-compute bar edges 
    // Here we are calculating the boundaries between bars, what frequencies do they start/stop at
    // Edges contains the left edge of boundary (the start freq) at i, and the right edge at i+1
    double[] edges = new double[rows + 1];
    for (int r = 0; r <= rows; r++)
    {
        edges[r] = Math.Pow(10, logMin + r * logStep);
	}

    // Loop over each FFT bin and for each:
    //  - Find which left and right edge it is between
    //  - Distribute it's power if it sits between/on an edge
    for (int bin = 1; bin < mags.Length; bin++)
    {
        double f = bin * sampleRate / (double)InstanceOptions._fftSize;
        if (f < edges[0] || f >= edges[^1]) continue;

        // Locate left edge index k so that edges[k] <= f < edges[k+1]
        int k = Array.BinarySearch(edges, f);
        if (k < 0) k = ~k - 1; // BinarySearch peculiarity

        double l = edges[k];
        double rEdge = edges[k + 1];
        double t = (f - l) / (rEdge - l); // 0->1 position between the two edges

        // distribute energy into the two adjacent bars
        double e = mags[bin] * mags[bin]; // energy to distribute
        
        power[k] += e * (1 - t); // left bar distribution
        binCnt[k] += (1 - t);

        if (k + 1 < rows) // right bar distribution (still inside range)
        {
            power[k + 1] += e * t;
            binCnt[k + 1] += t;
        }
    }


    // Clamp in range + Normalize
    // - Normalize the power by the ammount of FFT bins that contributed to a specific bar.
    // - Convert Amplitude to RMS to show the "average energy" of the bins that were added into a bar
    // - Clamp in the range of _dbRange where 0 is _dbFloor and 1 is _dbFloor + _dbRange
    var frame = new double[rows];
    for (int r = 0; r < rows; r++)
    {
        if (binCnt[r] == 0) { frame[r] = 0; continue; }

        // power -> amplitude -> dB
        double rms = Math.Sqrt(power[r] / binCnt[r]) * Math.Sqrt(binCnt[r]); 
        double db = 20 * Math.Log10(rms + 1e-20);

        double topDb = InstanceOptions._dbFloor + InstanceOptions._dbRange;
        double dbNorm = Math.Clamp((db - InstanceOptions._dbFloor) / InstanceOptions._dbRange, 0, 1);
        frame[r] = dbNorm;
    }

	// At this point we have values usable in our visualizer and format, 0.0->1.0 where 0 is no sound in(/around) that frequency and 1 is very loud sound in that frequency (clamped max, but can technically go "out of bounds")
	
	// Last part here is smoothing, we take each bar and "blur" it to the bars on either side
    var smoothed = new double[rows];
    for (int r = 0; r < rows; r++)
    {
        double sum = 0;
        int cnt = 0;
        // For -Smoothness to +Smoothness (2 smooth would be -2 -> 2)
        for (int s = -InstanceOptions._smooth; s <= InstanceOptions._smooth; s++)
        {
	        // If row +/- smooth is not negative and not more than the rows we have
	        if (r + s >= 0 && r + s < rows) 
	        { 
		        // Take that row at add it to our sum (and increase our total)
		        sum += frame[r + s]; 
				cnt++; 
	        }
        }
		
		// Avg the sum
        smoothed[r] = (sum / cnt);
    }

	// Now this frame is done and ready to be shown by the visualizer, so it's chucked into a ConcurrentQueue
	// I also check to make sure the UI isn't lagging too far behind by not letting the buffer get overfilled
    _frameQueue.Enqueue(smoothed);
    while (_frameQueue.Count > 13) _frameQueue.TryDequeue(out _);
}
</code>
</pre>
</br>
<img alt="Log10 Visualizer Gif" title="Log10 Visualizer Gif" src="https://www.dropbox.com/scl/fi/pso6m3w1xrdifjvvautih/Log10Demo.gif?rlkey=osa55fbotkpk6dpimonb20ppv&st=rjkpoxvi&raw=1" />
<p>Now we've got frames to show! I wont go over how I show them here, it's super simple anyway, just telling a rectangle to get taller based on 0->1 floats (and then coloring/position/etc).</p>
<h1 id="mdheadr--Making-it-look-better"> Making it look better</h1>
<p>The visualization works and looks decent, but in my opinion has some issues. For the algorithm above, I added smoothing to try and help Fix the jagged bars especially as your bar count grows in the low end. The Smoothness value determines how much peaks should "slide down" to adjacent bars to smooth out jagged waveforms. This helped but there were three other issues I wanted to fix:</p>
<ul>
<li> The low end takes up too much space leading to wide square waveforms as bars increase</li>
<li> Lots of noise bleed leads to uniformity without raising the db Floor</li>
<li> The high end is quiet and not very responsive (especially compared to the lows)</li>
</ul>
</br>
<p>For the first part, we can swap out the Log10 binning for any function that takes in a frequency and returns the bin it should hit. For my algorithm I define a low, mid, and high range. Then I can scale them separately, compressing the lows more than the mids, and compressing the highs more than the mids and the lows. However, splitting the compression like this leads to "boundary walls", where as the frequency increases/decreases through the boundary it sticks around the boundary points. This is because the "slope" of each section mismatches even though the bar values on the edges of each side may be close if not the same. To fix this we can compute the Derivatives for each section border and then use the <a href="https://en.wikipedia.org/wiki/Cubic_Hermite_spline">Cubic Hermite Spline</a> algorithm to find a "connection" between point A and point B. Point A and B will just be the boundary line +/- some transitional value. I wont cover the Cubic Hermite implementation because my brain doesn't like it and someone else could do it better. I highly recommend <a href="https://youtu.be/jvPPXbo87ds?si=lXTp0Kds1Ln0VjGG">Freya Holm√©r's video on Splines</a> which helped me wrap my head around many of the concepts.</p>
</br>
<pre class="code-block">
<code>
double[] edges = new double[rows + 1];
for (int r = 0; r <= rows; r++)
{
	// Old Easing
	// edges[r] = Math.Pow(10, logMin + r * logStep);
	
	// New Easing
    double t = r / (double)rows; // How far in the frequencies we are
    double easedT = TriEase(t); // Find where we should be instead (mapped bin)
    double logF = logMin + easedT * (logMax - logMin); // Map the T to the frequency range using the log fMin and log fMax
    edges[r] = Math.Pow(10, logF); // Convert back from log
}
</code>
</pre>
</br>
<pre class="code-block">
<code>
// Our Easing function. You could swap this func out to adjust how frequencies are mapped to bins
static double TriEase(double t, double lowMid = 0.3, double highMid = 0.7)
{
	// We split by percent, so 40% of the frequencies from 20-20000 are considered the low end
    lowMid = 0.40; // 40% Lows
    highMid = 0.95; // 85% (55% mid section, 5% highs)
    var transitionWidth = 0.02; // Smoothness value between low / mid / high

    if (t <= 0.0) return 0.0;
    if (t >= 1.0) return 1.0;

	// Compute derivatives at boundary points for smooth matching
    if (t < lowMid - transitionWidth)
    {
        // Low section
        double x = t / lowMid;
        return 0.5 * Math.Pow(x, 0.5);
    }
    else if (t < lowMid + transitionWidth)
    {
        // Smooth transition from low to mid
        double t1 = lowMid - transitionWidth;
        double t2 = lowMid + transitionWidth;

        // Values at transition points
        double v1 = 0.5 * Math.Pow(t1 / lowMid, 0.5);
        double v2 = 0.5 + ((t2 - lowMid) / (highMid - lowMid)) * 0.4;

        // Derivatives at transition points  
        double d1 = 0.5 * 0.5 * Math.Pow(t1 / lowMid, -0.5) / lowMid;
        double d2 = 0.4 / (highMid - lowMid);

        return CubicHermite(t, t1, v1, d1, t2, v2, d2);
    }
    else if (t < highMid - transitionWidth)
    {
        // Mid section
        double x = (t - lowMid) / (highMid - lowMid);
        return 0.5 + x * 0.4;
    }
    else if (t < highMid + transitionWidth)
    {
        // Smooth transition from mid to high
        double t1 = highMid - transitionWidth;
        double t2 = highMid + transitionWidth;

        // Values at transition points
        double v1 = 0.5 + ((t1 - lowMid) / (highMid - lowMid)) * 0.4;
        double v2 = 0.9 + 0.1 * Math.Pow((t2 - highMid) / (1 - highMid), 0.9);

        // Derivatives at transition points
        double d1 = 0.4 / (highMid - lowMid);
        double d2 = 0.1 * 0.9 * Math.Pow((t2 - highMid) / (1 - highMid), -0.1) / (1 - highMid);

        return CubicHermite(t, t1, v1, d1, t2, v2, d2);
    }
    else
    {
        // High section  
        double x = (t - highMid) / (1 - highMid);
        return 0.9 + 0.1 * Math.Pow(x, 0.9);
    }
}
</code>
</pre>
</br>
<p>This also solves part 3. Because we compress the highs, their combined energy makes them more visible. The last improvement happens within the Normalization + Clamping step. Using a Logistic Sigmoid Function we can gate out extra noise that washes out the spectrum's details. If we just gate the noise, say at 0.4, then that audio gets chopped and can visibly be seen as a wall in the waveform (0-1 becomes more like 0.1-1). So we use the Sigmoid as a Soft Gate to gradually ramp sounds we want muted down fast. (This applies more specifically for live audio visualizations, as pre generated ones don't get noise bleed as much. I'm not sure why this is though.)</p>
<pre class="code-block">
<code>
// The Normalizing + clamping section
var frame = new double[rows];
for (int r = 0; r < rows; r++)
{
    if (binCnt[r] == 0) { frame[r] = 0; continue; }

    // power -> amplitude -> dB
    double rms = Math.Sqrt(power[r] / binCnt[r]) * Math.Sqrt(binCnt[r]);
    double db = 20 * Math.Log10(rms + 1e-20);

    // Normalize the DB within the range
    double topDb = InstanceOptions._dbFloor + InstanceOptions._dbRange;
    double dbNorm = Math.Clamp((db - InstanceOptions._dbFloor) / InstanceOptions._dbRange, 0, 1);

	// New code!
	// Use Soft Gate to gate out noise and an exponential smoothstep to smooth out the missing cliff
    double t = r / (double)(rows - 1);
    frame[r] = Math.Clamp(ApplySoftKnee(dbNorm, t), 0, 1);
}
</code>
</pre>
</br>
<pre class="code-block">
<code>
static double ApplySoftGate(double x, double t)
{
    double center = 0.4; // How high is the gate
    double steep = 15.0; // How steep can we get (lower leads to more uniform waveforms)
    return 1.0 / (1.0 + Math.Exp(-steep * (x - center)));
}
</code>
</pre>
</br>
<img alt="Normalized Visualizer Gif" title="Normalized Visualizer Gif" src="https://www.dropbox.com/scl/fi/uvn18vg0adndnjylmxbdk/NormalizedDemo.gif?rlkey=q5ptfrpsqof7tyjvq6gpx2vzg&st=1wg6xjr7&raw=1" />
<p>Looking much better! BTW, both gifs are showing 0:13->0:28 of Caleb Belkin - For Her.</p>
</br>
<h1 id="mdheadr--Visualizations-using-FVZ"> Visualizations using FVZ</h1>
<p>Remember when I said "...it should be easy for developers interfacing with the server to be able to implement features... It's not the only visualization feature I want though." Well after working on making a visualizer UI for so long, I thought about how visualizers could work in Melon. The Fast Fourier Transform is a faster to compute version of the Discrete Fourier Transform, a very complex formula that can split the waves in a combined wave back into their parts. Sound is just a wave that is made of the combined frequencies in the signal, so we can split songs into their frequency spectrums using this formula with a small window of the audio that is playing right now. The original Discreet Fourier Transform is O(N^2), but the FFT brings this down to O(N log N). This is an improvement, but this is still complex. The N here is going to be mostly influenced by Resolution x Number of Frames. On my PC, running an RTX 4080 + Ryzen 7900X3D + 32GB of Memory, 60 seconds of audio at 8192x60fps, it takes 2.6667 seconds to compute. Per FFT that's only 0.7408ms per, however, running the FFT constantly in real time takes a toll. It's a costly operation that requires lots of multiply and add instructions on the CPU. Running it in real time while the system also works on other tasks can be overwhelming especially on mobile / embedded systems or systems without Hardware Acceleration. It can be a real battery drain.</p>
</br>
<p>So I decided to try and create a file format that could store pre-generated <b>F</b>requency <b>V</b>isuali<b>Z</b>ations. This format needed a few things for me:</p>
<ul>
<li> Flexibility</li>
<ul>
<li> Users may want visualizations to feel differently or may have audio that needs special treatment, for example quieter audio will need a lower db Floor.</li>
</ul>
<li> Compression</li>
<ul>
<li> Storing / Sending data for pre-generated FFT frames takes a lot of space. First tests with uncompressed data saved <code>Fox Stevenson - What Are You (Wow).flac</code> at 250x8192@120 (Bars x Res @ FPS) to 24,348kb which is roughly half the file's original size (a lot of extra data)</li>
</ul>
<li> Fast</li>
<ul>
<li> I have a LOT of music that will need pre generating and likely so will many using Melon. So, it needs to be as fast as I can get to encode, and even faster to decode on clients.</li>
</ul>
</ul>
</br>
<p>So say hello to the .fvz file! The encoder library allows for customizing tons of options about the visualization's bars, but ultimately just stores a header with some metadata and an array of arrays of floats, from 0->1. Like I mentioned earlier it's very large uncompressed, but luckily there are a few tricks I was able to use to compress it farther.</p>
</br>
<p>You can enable compression steps in custom patterns. First is standard Zstd 3 Compression, which nets you large reduction off the bat. Next is Quantization. Our floats start as 32bit, but we can quantize them down to 16 or 8 bit without loosing too much information (4 bit starts to look bad). Lastly I've added Delta Encoding from frame-to-frame. This means instead of storing the actual value each bar is in each frame, we store the difference from last frame to this frame. This only really helps when the change from frame to frame is small enough to keep variance across the file low enough for Zstd to optimize it. Below is a size comparison chat using <code>Fox Stevenson - What Are You (Wow).flac</code> at 250x8192@120 (Bars x Res @ FPS)</p>
</br>
<table>
    <tr>
        <td>Compression Type</td>
        <td>File Size</td>
    </tr>
    <tr>
        <td>Original Flac File</td>
        <td>52,249 kb</td>
    </tr>
    <tr>
        <td>Uncompressed</td>
        <td>24,348 kb</td>
    </tr>
    <tr>
        <td>Zstd 3</td>
        <td>22,047 kb</td>
    </tr>
    <tr>
        <td>+ Quant -&gt; 16</td>
        <td>13,491 kb</td>
    </tr>
    <tr>
        <td>+ Quant -&gt; 8</td>
        <td>6,160 kb</td>
    </tr>
    <tr>
        <td>+ Delta Encode</td>
        <td>3,394 kb</td>
    </tr>
</table>
</br>
<p>I think it's about as small as I can get it for now, and I feel it's small enough for my use case. It's not too much extra data and it's faster than the song is to transmit. The file in this example is 4:19 long and took roughly 4.7 seconds to complete generating. I've seen a range of 2-8 seconds on the various other songs and test files I've used. It seems to stay roughly 1 second per minute of audio. I would love to find a way to compress below 1mb though!</p>
</br>
<h2 id="mdheadr--FFTVIS-Encoder/Decoder"> FFTVIS Encoder/Decoder</h2>
</br>
<p>The frame generator is mostly the same from the one showed in the live audio visualizer, just changed to support taking in data from a file rather than live asap. So I won't cover it here! The Encoder and Decoder use a bitmask + bool from the header to determine the compression used. An .FVZ file header looks like this:</p>
<pre class="code-block">
<code>
public struct Metadata // 36 bytes long w/ padding
{
    [MarshalAs(UnmanagedType.ByValArray, SizeConst = 6)]
    public byte[] magic; // 'FFTVIS'
    public int version; // 2 currently
    public uint fftResolution; // FFT generation Resolution
    public ushort numBands; // Number of bands generated for display
    public ushort frameRate; // FPS of generation
    public uint totalFrames; // Total # of frames contained
    public float maxAmplitude; // Maximum amplitude of the samples read
    public ushort compressionType; // 0001 - ZSTD, 0010 - Quant, 0100 - Deltas
    public bool quantizeLevel; // false - 16, true - 8
}
</code>
</pre>
</br>
<p>The Zstd step is made easy thanks to <a href="https://github.com/skbkontur/ZstdNet">ZstdNet</a>:</p>
<pre class="code-block">
<code>
// Convert our frames into a flat array 
double[] all = new double[totalSamples];
for (int i = 0; i < GeneratedFrames.Length; i++)
    Array.Copy(GeneratedFrames[i], 0, all, i * frameLen, frameLen);

// Copy the flat array over to it's bytes
bytes = new byte[all.Length * sizeof(double)];
Buffer.BlockCopy(all, 0, bytes, 0, bytes.Length);

// Compress
using (var compressor = new Compressor())
{
    byte[] compressed = compressor.Wrap(bytes);
    fs.Write(BitConverter.GetBytes(compressed.Length));
    fs.Write(compressed, 0, compressed.Length);
}
</code>
</pre>
</br>
<p>For Quantization it's also quite easy, but I have 2 different versions, signed and unsigned. Signed is used when delta encoding, as it's -1 -> 1 instead of 0-1. They all share the same structure:</p>
<pre class="code-block">
<code>
private static ushort[] Quantize16(double[] input)
{
    ushort[] output = new ushort[input.Length];
    for (int i = 0; i < input.Length; i++)
        output[i] = (ushort)Math.Clamp((int)Math.Round(input[i] * 65535), 0, 65535);
    return output;
}
</code>
</pre>
</br>
<p>However, the actual math changes:</p>
<pre class="code-block">
<code>
// Unsigned 16
(ushort)Math.Clamp((int)Math.Round(input[i] * 65535), 0, 65535);
// Signed 16
(short)Math.Clamp((int)Math.Round((value * 2.0 - 1.0) * 32767.0), -32767, 32767);
// Unsigned 8
(byte)Math.Clamp((int)Math.Round(input[i] * 255), 0, 255);
// Signed 8
(sbyte)Math.Clamp((int)Math.Round((value * 2.0 - 1.0) * 127.0), -127, 127);
</code>
</pre>
</br>
<p>Lastly I added Delta Encoding to try and get better compression but it rarely wins out and is usually the same size as without it. Where it wins out is when there is little variance in the audio being played or the visualization DB floor/range let in little audio.</p>
<pre class="code-block">
<code>
double[] prevFrame = new double[frameLen]; // Last frame to get difference frome
double[] allDeltas = new double[totalSamples]; // output deltas

for (int i = 0; i < GeneratedFrames.Length; i++)
{
    var frame = GeneratedFrames[i];

    // Compute deltas between values 
    // (quantizing deltas leads to drift so quantize first)
    for (int j = 0; j < frameLen; j++)
    {
        allDeltas[i * frameLen + j] = frame[j] - prevFrame[j];
    }

    // Update previous frame
    prevFrame = frame;
}

bytes = new byte[allDeltas.Length * sizeof(double)];
Buffer.BlockCopy(allDeltas, 0, bytes, 0, bytes.Length);
</code>
</pre>
</br>
<p>For the decoder it's all the same but in reverse! Zstd has to decompress first, then Quants are divided, and Deltas are added up back to their original values.</p>
</br>
<h2 id="mdheadr--FVZ-Settings"> FVZ Settings</h2>
<p>When generating .fvz files with the FFTVIS Library, you get lots of control over how visualizations should be created. The following settings are available:</p>
<ul>
<li> Bar Count</li>
<ul>
<li> How many bars to bin frequencies into</li>
</ul>
<li> DB Floor</li>
<ul>
<li> The floor to ignore sound below, a negative number. Lower lets in more sound, -70 -> -90 is typically recommended for music files</li>
</ul>
<li> DB Range</li>
<ul>
<li> The range of DB amplitudes being displayed. Lower values exaggerate values while higher values smooth the waveform out. 70-120 is typically normal.</li>
</ul>
<li> Frequency Min</li>
<ul>
<li> The lowest frequency to display, typically 20hz.</li>
</ul>
<li> Frequency Max</li>
<ul>
<li> The maximum frequency to display, typically 20000hz.</li>
</ul>
<li> Smoothness</li>
<ul>
<li> How much to smooth out peaks, by averaging +/- Smoothness bars.</li>
</ul>
<li> Bin Map</li>
<ul>
<li> How to map frequencies to bins</li>
<li> FFTVIS's C# Library supports Log10, Mel, and the custom Normalized preset. .fvz files are agnostic to this though, all they need to know is what the data looks like after. So you could add custom bin maps if mine aren't what you're looking for.</li>
</ul>
<li> FFT Resolution</li>
<ul>
<li> The window of samples to run FFT analysis on, MUST BE A MULTIPLE OF 2</li>
<li> Typically 2048, 4096, 8192, 16384</li>
</ul>
<li> FPS</li>
<ul>
<li> The frame rate to render at. Typically no need to exceed 240 and not worth going below 60.</li>
</ul>
<li> Compression Type</li>
<ul>
<li> A bitmask (in the C# lib, an Enum flag object) that describes which steps to use for encoding and decoding the file w/ compression.</li>
<li> 0001 - ZSTD, 0010 - Quant, 0100 - Deltas</li>
</ul>
<li> Quantization Level</li>
<ul>
<li> 16 bit or 8 bit, only used if the bitmask is set for Quantization</li>
</ul>
</ul>
</br>
<h2 id="mdheadr--FVZ-Examples"> FVZ Examples</h2>
<p>I've made a quick JS implementation of the decoder, so you can enjoy live examples of real .fvz files being played back! No audio (gotta play nice with Mr. Copyright), but can you guess the songs being played? (You can check by clicking the blurred text below!)</p>
</br>

<div id="visualizer" class="visualizer-container" style="display: block;">
    <canvas id="visualizerCanvas" class="visualizer-canvas" width="800" height="400"></canvas>
    
    <div class="controls">
        <button id="playBtn">Play</button>

        <div class="timeline">
            <input type="range" id="timelineSlider" min="0" max="100" value="0" disabled>
        </div>
    </div>
    
    <div class="info-panel">
        <div>
            <span id="currentTime">00:00</span> / <span id="totalTime">00:00</span>
        </div>
        <div>
            <span class="songName songNameHidden" title="Reveal Song Name">Scatman John - Scatman's World</span>
        </div>
        <div>
            Frame: <span id="currentFrame">0</span> / <span id="totalFrames">0</span>
        </div>
    </div>
</div>

<div id="visualizer2" class="visualizer-container" style="display: block;">
    <canvas id="visualizerCanvas2" class="visualizer-canvas" width="800" height="400"></canvas>
    
    <div class="controls">
        <button id="playBtn2">Play</button>

        <div class="timeline">
            <input type="range" id="timelineSlider2" min="0" max="100" value="0" disabled>
        </div>
    </div>
    
    <div class="info-panel">
        <div>
            <span id="currentTime2">00:00</span> / <span id="totalTime2">00:00</span>
        </div>
         <div>
            <span class="songName songNameHidden" title="Reveal Song Name">Caleb Belkin - for her.</span>
        </div>
        <div>
            Frame: <span id="currentFrame2">0</span> / <span id="totalFrames2">0</span>
        </div>
    </div>
</div>

<div id="visualizer3" class="visualizer-container" style="display: block;">
    <canvas id="visualizerCanvas3" class="visualizer-canvas" width="800" height="400"></canvas>
    
    <div class="controls">
        <button id="playBtn3">Play</button>

        <div class="timeline">
            <input type="range" id="timelineSlider3" min="0" max="100" value="0" disabled>
        </div>
    </div>
    
    <div class="info-panel">
        <div>
            <span id="currentTime3">00:00</span> / <span id="totalTime3">00:00</span>
        </div>
         <div>
            <span class="songName songNameHidden" title="Reveal Song Name">Fox Stevenson - What Are You (Wow)</span>
        </div>
        <div>
            Frame: <span id="currentFrame3">0</span> / <span id="totalFrames3">0</span>
        </div>
    </div>
</div>

</br>
<h1 id="mdheadr--WASAPI-Woes"> WASAPI Woes</h1>
</br>
<h2 id="mdheadr--Per-Process"> Per Process</h2>
<p>While I was working on the audio visualizer, just for fun, I decided I wanted to see if I could split up process audio and show different colors/visualizer settings for individual processes. Starting in Windows 10 Build 20348 (aka Windows Server 2022) and up you can use <a href="https://learn.microsoft.com/en-us/windows/win32/api/audioclientactivationparams/ns-audioclientactivationparams-audioclient_activation_params">AUDIO_CLIENT_ACTIVATIONPARAMS</a> to specify a filter with a process ID. I struggled a lot trying to get this to work through PInvoking windows APIs but at the time of looking in to this NAudio hadn't implemented support yet. After some digging I ran into <a href="https://github.com/JustArion/NAudio/tree/process-audio-capture">JustArion's PR with a working implementation</a> but still ran into trouble. After many frustrating hours of debugging I discovered that instead of providing 32-bit floats like the WASAPI normally does, when doing per-process the audio is provided as PCM-16. (I never realized that would be the case D:) After decoding it as PCM-16 it looks (mostly) correct! If you're looking to do anything similar in C#, you can follow the <a href="https://github.com/microsoft/windows-classic-samples/tree/main/Samples/ApplicationLoopback">reference cpp implementation</a> and write a wrapping around the WASAPIs, or you could also check out this <a href="https://github.com/qH0sT/ApplicationLoopBack">library from qH0sT</a> or use JustArion's NAudio fork on the process-audio-capture branch. NAudio hasn't <a href="https://github.com/naudio/NAudio/issues/878">merged in support</a> just yet (as these are all relatively new APIs and implementations for them). This also means that if you want to build FreqFreak, you'll need to reference JustArion's version of NAudio.</p>
</br>
<h2 id="mdheadr--Timing"> Timing</h2>
<p>Another fun issue I ran into was timing. Calling from the WASAPI will just give you audio as needed, so the UI system is designed to just ask for the current frame as fast as it can render them. However when building the FVZ player into FreqFreak, I ran into issues trying to play back any file rendered at above 60fps. Firstly, you can't easily delay a thread on windows past 60 fps, roughly 16hz, because the system clock runs at 15. If you try to delay any less time than 15ms, you will still wait 15ms. This is because the system clock literally cannot see the time in between it's refresh rate, so it will not know you've passed 5ms until it refreshes itself up to 10ms later.</p>
</br>
<p>The second problem is the WASAPI. There is an odd bug that has persisted across all the forms of the WASAPI I've used (WASADK, CPP APIs, NAudio's Wrapper). If you attempt to seek the song using the seek function, there is a large chance that instead of seeking to, for example, 1 minute in, it will seek to 1, but SAY that it's at 1:06? This results in two things: one the current timestamp is invalid, and two the song ends roughly 6 seconds early, because it thinks it's farther ahead than it is. I have no idea what audio files make it do this, it does it to FLAC, 44100, 48000, 88000. It does it to mp3, it does it to m4a. Truly I have no clue what the the deal is. But I do have a (very stupid) workaround. Why seek your file using the API when you can just. Cut your file at the bytes you want to skip, then tell windows to shut up and play this "new file" from the beginning. If you never seek it never looses position. </p>
</br>
<p>I hadn't encountered issues with this solution yet, till now. This means that I have to store time seprately, because I not only cannot trust the WASAPI's position, I cannot just ask NAudio WaveOut how far into the file it is (because it's not the full file). NAudio's AudioFileReader knows (because I use the OffsetSampleProvider to skip bytes for seeking) and returns it as a timestamp, but if you bombard it asking for the current time as fast as possible, it grinds the app down to 5fps or less. I also, as mentioned above, cannot just ask the thread to wait say 4.16ms for 240fps because the system clock cannot see that time. So my implementation just unrestricted asks for the next frame as soon as it's done showing the last frame, and we calculate where we are by asking when did we start (or when we lasted seeked and where to) and when we are now. The difference of the start to now equals the elapsed time and position in the song, which I can use to determine the current frame to pull. This was implemented as a custom PlaybackTimer class. However, all of this is dumb and in JS I'm able to just ask the audio player "hey when are we" and it just works, so thanks msft lol.</p>
</br>
<p>Lastly, I ran into a super small issue when building the Encoder for FVZ that breaks higher frame rates as well. This one took me awhile to figure out, partially because it was happening at the same time as the timing issue above. Lets start by looking at this original function for generating frames from a file. The goal here is to take a known FPS + Total time and decide on how much we should hop each frame in order to hit the FPS we want (and then extract those bytes for building into frames).</p>
<pre class="code-block">
<code>
public bool GenerateFrames(IProgress<double>? progress = null) 
{ 
	if (_audio.Length == 0) return false; 

	// Hop forward by samplerate / FPS
	double hop = Math.Ceiling((double)_format.SampleRate / FPS); 

	// How many frames will we need
	int frameCount = (int)Math.Ceiling(Math.Max(0, (_audio.Length - FFTResolution) / hop + 1)); 
	
	GeneratedFrames = new double[frameCount][]; // Storage

	// Parallel loop for SPEED
	Parallel.For(0, frameCount, new ParallelOptions { MaxDegreeOfParallelism = Environment.ProcessorCount }, i => 
	{
		var fb = CreateBuilder(); // FrameBuilder class
		// The window of data to process
		float[] window = _floatPool.Rent(FFTResolution); 
		try { 
			// What byte should we start at?
			int src = (int)Math.Floor(i * hop); 
			if (_audio.Length < src + FFTResolution) // If we don't have samples left for the last frame of audio, get the rest and work with it
			{ 
				// Copy last section 
				int dif = src + FFTResolution - _audio.Length; Array.Copy(_audio, src, window, 0, dif); 
			} 
			else 
			{ 
				// Copy normally 
				Array.Copy(_audio, src, window, 0, FFTResolution); 
			} 
			GeneratedFrames[i] = fb.ProcessData(window, _format) ?? new double[BarCount]; 
		} 
		finally 
		{ 
			// Free pool we rented so they don't charge us late fees
			_floatPool.Return(window); 
		} 
		progress?.Report(frameCount); 
	}); 
		
	_md.totalFrames = (uint)frameCount; 
	return true; 
}
</code>
</pre>
</br>
<p>So if you're smarter than me you might have been able to catch the issue. See at higher frame rates we may have a hop size that is fractional. If it is, it needs to become rounded to an int eventually, because we don't have fractional frame indexes. However, in this attempt I did something incorrect. Here I take the ceiling and of the hop making it an int early. Floor is never really used here (but it also would have been wrong). By doing this, I quantize the position (i) before multiplying it by the hop. This leads to reduced precision, but more importantly, reduced precision that compounds each frame. Being a fraction of a second behind means being seconds behind minutes into a song.</p>
<pre class="code-block">
<code>
// Dont round your hop
// Ceiling leads to visuals being early
// Floor leads to them being late
double hop = Math.Ceiling((double)_format.SampleRate / FPS); 
int src = (int)Math.Floor(i * hop); // Don't use Floor, use Round
</code>
</pre>
</br>
<p>So instead those two lines are swapped out with these 3. Our hop size is now fractional. But also very importantly we use Round. Just using floor or ceiling on your src will also lead to a compounding effect. But by using round you flipflop between going slightly ahead and slightly behind in the fractions of a second. This never becomes noticeable, and the range remains low. For example: 60 seconds at 500 FPS (88.2 hop size) leads to bounding at -0.4 -> 0.4.</p>
<pre class="code-block">
<code>
// Fractional hop
double hop = _format.SampleRate / (double)FPS; 

// Rounded src
double fracSrc = i * hop; 
int src = (int)Math.Round(fracSrc);
</code>
</pre>
</br>
<p>To "Show My Work" on the bounding, you can use this to watch the error value.</p>
<pre class="code-block">
<code>
double fs = 44100.0; // Sample rate
double fps2 = 500.0; // Visualiser frame rate
double hop = fs / fps2; 

int frames = 60 * (int)fps2;
double errMin = 0.0, errMax = 0.0;

for (int i = 0; i < frames; i++)
{
    double exact = i * hop; // Ideal start (fractional)
    double rounded = Math.Round(exact); // Chosen integer sample
    double err = rounded - exact; // Instantaneous error

    if (err < errMin) errMin = err;
    if (err > errMax) errMax = err;
}

Console.WriteLine($"Error range after {frames} frames: {errMin:0.###} -> {errMax:0.###}");
</code>
</pre>
</br>
<h1 id="mdheadr--Notes-on-Visualizations"> Notes on Visualizations</h1>
<p>Some interesting extra notes on things I've noticed playing around with visualization settings:</p>
<ul>
<li> When using FVZ to generate, 8192 is typically perfect for 44100hz and 48000hz sample rate files. When playing files in 88khz like The Weeknd - Hurry Up Tomorrow, 8192 looks more like 4096, and so 16384 becomes a more valid FFT Resolution.</li>
<li> When playing audio live, depending on application audio volume, -80 -> -120 can be good DB Floors, but when generating from a file direct, -60 -> -90 tends to work better.</li>
<li> DB Ranges of 40-60 are very peaky, 70-90 being balanced, and 100-130 being more uniform/flat</li>
<li> When using Normalized 20-20000hz is best, but in Log10 it can be helpful to cut out some lows to 40-60 to remove the odd stretching.</li>
<li> Live visuals are always more jittery than Generated.</li>
<li> Per process audio visuals are far more jittery. My assumption is this is an effect of being PCM 16 instead of 32, but I don't know why or how to help it not be this way. Best solution can be to lower attack/decay speeds to get more smooth playback.</li>
<li> There is a limit to how much you can "stretch" (add more bars) before it starts to stretch bars like the lows into jagged/blocky representations. This suggests to me there is an upper "worth it" limit for bar count. It differs per FFT resolution, but in Live it is unreasonable to go higher than 16k without having "lag" from having to wait for more samples to fill the buffer. In both modes more than 16k res is almost never worth it(unless your sample rate is much higher, vinyl res at 192000 might need 32k res), as it takes in too much song at a time and thus averages too much area to look accurate.</li>
</ul>
</br>
<h1 id="mdheadr--Wrap-up-and-Downloads"> Wrap up and Downloads</h1>
<p>SO! Lots of work went in to this, and after multiple days of polishing up and writing this blog and researching, I'm ready to release it! There will be project pages with some details + downloads for both FreqFreak, the Windows audio visualizer and FVZ player, as well as FFTVIS, the file format .fvz used to store pregenerated visuals + it's C# library and JS Decoder implementation. You can find links to them below or in the project section of this site :D</p>
</br>
<p>All the code for these projects is Open Source, feel free to download, use, modify, and build other systems with the tools found here! If you have suggestions, or find any bugs, please submit an issue or a PR. I hope you enjoy them, and if you're working on similar projects to these, I hope some of the things I've learned and detailed here can be of assistance. Having the desync from both dual timers and the float rounding was a nightmare lol, hard to place when it's two parts of the pipeline contributing two levels of drift.</p>
</br>
<ul>
<li> <a href="/site/project?id=FreqFreak">FreqFreak</a></li>
<li> <a href="/site/project?id=fftvis">FFTVIS</a></li>

                </div>
            </article>
        <div class="blog-post-page">
                <div id="comments-header">
                    <h1>Comments</h1>
                </div>
                <hr id="comments-divider"/>
                <div id="comments-section">
                    <div id="loading-bar-container" style="position: relative; width: 100%; height: 5px; background-color: var(--accent-secondary); overflow: hidden; display: none;">
                        <div id="loading-bar" style="width: 30%; height: 100%; background-color: var(--accent); position: absolute; animation: loading 1.5s infinite;"></div>
                      </div>
                      
                </div>
            </div>
        </main>

        <div id="settings-bg">
            <div id="settings-modal" class="themebtn">
                <a aria-label="page-settings" class="social-link" id="close-modal">
                    <svg  xmlns="http://www.w3.org/2000/svg"  width="24"  height="24"  viewBox="0 0 24 24"  fill="none"  stroke="currentColor"  stroke-width="2"  stroke-linecap="round"  stroke-linejoin="round"  class="icon icon-tabler icons-tabler-outline icon-tabler-x"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M18 6l-12 12" /><path d="M6 6l12 12" /></svg>
                </a>
                <p class="themebtn" style="font-size: 0.8em; margin-left: 0px; position: relative;"><i class="themebtn"><span class="version-display"></span> &#x2022; <a class="changelog-link themebtn" href="/site/changelog">changelog</a></i></p>
                <label class="themebtn">Select Theme:</label>
                <div class="toggle-container themebtn">
                    <label class="toggle-switch themebtn">
                        <input class="themebtn" type="checkbox">
                        <span class="slider themebtn"></span>
                    </label>
                    <p class="themebtn transparent-desc">Enable Transparent Effects <span class="themebtn" title="If your browser supports transparent backgrounds, you can enable this to make the site theme show through to your desktop (or browser bg).">&#x1F6C8</span></p>
                </div>

                <div class="theme-picker themebtn">
                    <div class="theme-option tooltip themebtn" id="theme-option-notebook">
                        <span class="tooltiptext themebtn">Notebook</span>
                        <div class="theme-sidebar themebtn" style="background-color: #f1e4c1;"></div>
                        <div class="theme-main themebtn" style="background-color: #fff9e8;">
                            <div class="theme-card themebtn" style="background-color: #f7f2e0;"></div>
                        </div>
                    </div>
                    <div class="theme-option tooltip themebtn" id="theme-option-light" >
                        <span class="tooltiptext themebtn">Flashbang</span>
                        <div class="theme-sidebar themebtn" style="background-color: rgb(216, 216, 216);"></div>
                        <div class="theme-main themebtn" style="background-color: rgb(228, 228, 228);">
                            <div class="theme-card themebtn" style="background-color: rgb(199, 199, 199);"></div>
                        </div>
                    </div>
                    <div class="theme-option tooltip themebtn" id="theme-option-transparent">
                        <span class="tooltiptext themebtn">Snow Day</span>
                        <div class="theme-sidebar themebtn" style="background: #b1c9e1;"></div>
                        <div class="theme-main themebtn" style="background: #d9eafd;">
                            <div class="theme-card themebtn" style="background-color: #bcccdc;"></div>
                        </div>
                    </div>
                    <div class="theme-option tooltip themebtn" id="theme-option-dark">
                        <span class="tooltiptext themebtn">Dark</span>
                        <div class="theme-sidebar themebtn" style="background-color: #2a2a2a;"></div>
                        <div class="theme-main themebtn" style="background-color: #1a1a1a;">
                            <div class="theme-card themebtn" style="background-color: rgb(53, 53, 53);"></div>
                        </div>
                    </div>
                    <div class="theme-option tooltip themebtn" id="theme-option-ocean">
                        <span class="tooltiptext themebtn">Ocean</span>
                        <div class="theme-sidebar themebtn" style="background-color: #073642;"></div>
                        <div class="theme-main themebtn" style="background-color: #002b36;">
                            <div class="theme-card themebtn" style="background-color: #083c4a;"></div>
                        </div>
                    </div>
                    <div class="theme-option tooltip themebtn" id="theme-option-dream">
                        <span class="tooltiptext themebtn">Dream</span>
                        <div class="theme-sidebar themebtn" style="background-color: #2c2a3e;"></div>
                        <div class="theme-main themebtn" style="background-color: #2b2336;">
                            <div class="theme-card themebtn" style="background-color: #3b3f51;"></div>
                        </div>
                    </div>
                    <div class="theme-option tooltip themebtn" id="theme-option-fields">
                        <span class="tooltiptext themebtn">Fields</span>
                        <div class="theme-sidebar themebtn" style="background-color: #365142;"></div>
                        <div class="theme-main themebtn" style="background-color: #283c2e;">
                            <div class="theme-card themebtn" style="background-color: #2d543f;"></div>
                        </div>
                    </div>
                    <div class="theme-option tooltip themebtn" id="theme-option-sunset">
                        <span class="tooltiptext themebtn">Sunset</span>
                        <div class="theme-sidebar themebtn" style="background-color: #4c1919;"></div>
                        <div class="theme-main themebtn" style="background-color: #381324;">
                            <div class="theme-card themebtn" style="background-color: #403949;"></div>
                        </div>
                    </div>
                    <div class="theme-option tooltip themebtn" id="theme-option-matrix">
                        <span class="tooltiptext themebtn">Matrix</span>
                        <div class="theme-sidebar themebtn" style="background-color: #000000;"></div>
                        <div class="theme-main themebtn" style="background-color: #0e0e0e;">
                            <div class="theme-card themebtn" style="background-color: #1a1a1a;"></div>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <aside class="toc" onclick="">
            <div class="toc-icon">‚ò∞</div> 
            <div class="toc-content" id="toc-site-nav"></div>
            <div class="toc-content" id="toc-post-nav">
            <ul>
                <a aria-label="page-settings" class="social-link" id="page-settings">
                    <li class="settingsbtn">
                        <svg xmlns="http://www.w3.org/2000/svg"  width="24"  height="24"  viewBox="0 0 24 24"  fill="none"  stroke="currentColor"  stroke-width="2"  stroke-linecap="round"  stroke-linejoin="round"  
                        class="icon icon-tabler icons-tabler-outline icon-tabler-adjustments settingsbtn "
                        style="margin-right: 3px;">
                            <path stroke="none" d="M0 0h24v24H0z" fill="none" class="settingsbtn"/>
                            <path d="M4 10a2 2 0 1 0 4 0a2 2 0 0 0 -4 0" class="settingsbtn"/>
                            <path d="M6 4v4" class="settingsbtn"/>
                            <path d="M6 12v8" class="settingsbtn"/>
                            <path d="M10 16a2 2 0 1 0 4 0a2 2 0 0 0 -4 0" class="settingsbtn"/>
                            <path d="M12 4v10" class="settingsbtn"/>
                            <path d="M12 18v2" class="settingsbtn"/>
                            <path d="M16 7a2 2 0 1 0 4 0a2 2 0 0 0 -4 0" class="settingsbtn"/>
                            <path d="M18 4v1" class="settingsbtn"/>
                            <path d="M18 9v11" class="settingsbtn"/>
                        </svg>
                        Settings
                    </li>
                </a>
                <hr style="margin: 10px 10px 10px 5px;" id="setdivider"/>
                <a href="#mdpost-title"><li>Audio Visualizations in C#</li></a>
<a href="#mdheadr--FFT-Visualization-Pipeline-Code"><li> FFT Visualization Pipeline Code</li></a>
<a href="#mdheadr--Getting-Audio"><li> Getting Audio</li></a>
<a href="#mdheadr--Getting-Visualizer-Frames"><li> Getting Visualizer Frames</li></a>
<a href="#mdheadr--Making-it-look-better"><li> Making it look better</li></a>
<a href="#mdheadr--Visualizations-using-FVZ"><li> Visualizations using FVZ</li></a>
<a href="#mdheadr--FFTVIS-Encoder/Decoder"><li> FFTVIS Encoder/Decoder</li></a>
<a href="#mdheadr--FVZ-Settings"><li> FVZ Settings</li></a>
<a href="#mdheadr--FVZ-Examples"><li> FVZ Examples</li></a>
<a href="#mdheadr--WASAPI-Woes"><li> WASAPI Woes</li></a>
<a href="#mdheadr--Per-Process"><li> Per Process</li></a>
<a href="#mdheadr--Timing"><li> Timing</li></a>
<a href="#mdheadr--Notes-on-Visualizations"><li> Notes on Visualizations</li></a>
<a href="#mdheadr--Wrap-up-and-Downloads"><li> Wrap up and Downloads</li></a>

            </ul>
            </div>
        </aside>
    </div>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/dompurify/2.3.10/purify.min.js"></script>
    <script src="/js/toc.js"></script>
    <script src="https://unpkg.com/fzstd@0.1.1"></script>
    <script src="/js/fvzDecoder.js"></script>
    <script src="/js/fvz.js"></script>
    <script src="/js/settings.js"></script>
    <script src="/js/comments.js"></script>
    <link id="codeTheme" rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/atom-one-dark.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    <script>hljs.highlightAll();</script>
</body>
</html>

